import torch.nn.init


def 权重初始归一化(模型):
    类名 = 模型.__class__.__name__
    if 类名.find("卷积") != -1:
        torch.nn.init.normal_(模型.weight.data, 0.0, 0.02)
    elif 类名.find("二维批归一化") != -1:
        torch.nn.init.normal_(模型.weight.data, 1.0, 0.02)
        torch.nn.init.constant_(模型.bias.data, 0.0)


def 载入分类列表(路径):
    文件 = open(路径, "r")
    名称列表 = 文件.read().split("\n")[:-1]
    return 名称列表


def 到中央处理器(张量):
    return 张量.detach().cpu()


def 盒子边界宽和高的交并比(锚定盒, 目标盒子的宽和高):
    目标盒子的宽和高 = 目标盒子的宽和高.t()
    宽1, 高1 = 锚定盒[0], 锚定盒[1]
    宽2, 高2 = 目标盒子的宽和高[0], 目标盒子的宽和高[1]
    相交面积 = torch.min(宽1, 宽2) * torch.min(高1, 高2)
    相并面积 = (宽1 * 高1 + 1e-16) + 宽2 * 高2 - 相交面积
    return 相交面积 / 相并面积


def 盒子边界的交并比(预测的盒子, 目标的盒子, 不转换坐标=True):
    if not 不转换坐标:
        预测的盒子_x1, 预测的盒子_x2 = 预测的盒子[:, 0] - 预测的盒子[:, 2] / 2, 预测的盒子[:, 0] + 预测的盒子[:, 2] / 2
        预测的盒子_y1, 预测的盒子_y2 = 预测的盒子[:, 1] - 预测的盒子[:, 3] / 2, 预测的盒子[:, 1] + 预测的盒子[:, 3] / 2
        目标的盒子_x1, 目标的盒子_x2 = 目标的盒子[:, 0] - 目标的盒子[:, 2] / 2, 目标的盒子[:, 0] + 目标的盒子[:, 2] / 2
        目标的盒子_y1, 目标的盒子_y2 = 目标的盒子[:, 1] - 目标的盒子[:, 3] / 2, 目标的盒子[:, 1] + 目标的盒子[:, 3] / 2
    else:
        预测的盒子_x1, 预测的盒子_y1, 预测的盒子_x2, 预测的盒子_y2 = 预测的盒子[:, 0], 预测的盒子[:, 1], 预测的盒子[:,
                                                                                                         2], 预测的盒子[
                                                                                                             :, 3]
        目标的盒子_x1, 目标的盒子_y1, 目标的盒子_x2, 目标的盒子_y2 = 目标的盒子[:, 0], 目标的盒子[:, 1], 目标的盒子[:,
                                                                                                         2], 目标的盒子[
                                                                                                             :, 3]

    相交区域_x1 = torch.max(预测的盒子_x1, 目标的盒子_x1)
    相交区域_y1 = torch.max(预测的盒子_y1, 目标的盒子_y1)
    相交区域_x2 = torch.min(预测的盒子_x2, 目标的盒子_x2)
    相交区域_y2 = torch.min(预测的盒子_y2, 目标的盒子_y2)
    相交面积 = torch.clamp(相交区域_x2 - 相交区域_x1 + 1, min=0) * torch.clamp(相交区域_y2 - 相交区域_y1 + 1, min=0)

    预测的盒子的面积 = (预测的盒子_x2 * 预测的盒子_x1 + 1) * (预测的盒子_y2 * 预测的盒子_y1 + 1)
    目标的盒子的面积 = (目标的盒子_x2 * 目标的盒子_x1 + 1) * (目标的盒子_y2 * 目标的盒子_y1 + 1)

    交并比 = 相交面积 / (预测的盒子的面积 + 目标的盒子的面积 - 相交面积 + 1 + 1e-16)

    return 交并比


def 构建目标列表(预测的盒子列表, 预测的分类列表, 目标列表, 锚定盒列表, 忽略用阈值):
    浮点型张量 = torch.cuda.FloatTensor if 预测的盒子列表.is_cuda else torch.FloatTensor
    字节型张量 = torch.cuda.ByteTensor if 预测的盒子列表.is_cuda else torch.ByteTensor

    每批图片数量 = 预测的盒子列表.size(0)
    锚定盒数量 = 预测的盒子列表.size(1)
    类别数量 = 预测的分类列表.size(-1)
    预测的盒子尺寸 = 预测的盒子列表.size(2)

    有对象的掩码列表 = 字节型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)
    无对象的掩码列表 = 字节型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(1)
    分类的掩码列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)
    交并比分数列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)

    预设目标中x的列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)
    预设目标中y的列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)
    预设目标中宽的列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)
    预设目标中高的列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸).fill_(0)
    预设目标分类的列表 = 浮点型张量(每批图片数量, 锚定盒数量, 预测的盒子尺寸, 预测的盒子尺寸, 类别数量).fill_(0)

    目标盒子列表 = 目标列表[:, 2:6] * 预测的盒子尺寸
    目标盒子的中心点列表 = 目标盒子列表[:, :2]
    目标盒子的宽和高列表 = 目标盒子列表[:, 2:]

    交并比列表 = torch.stack([盒子边界宽和高的交并比(锚定盒, 目标盒子的宽和高列表) for 锚定盒 in 锚定盒列表])
    print("交并比列表", 交并比列表.shape)
    最佳_交并比列表, 最佳_交并比索引列表 = 交并比列表.max(0)

    图片索引列表, 目标标签列表 = 目标列表[:, :2].long().t()
    目标盒子x列表, 目标盒子y列表 = 目标盒子的中心点列表.t()
    目标盒子宽列表, 目标盒子高列表 = 目标盒子的宽和高列表.t()
    # 向下取整
    目标盒子y取整列表, 目标盒子x取整列表 = 目标盒子的中心点列表.long().t()
    有对象的掩码列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = 1
    无对象的掩码列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = 0

    for 索引, 交并比 in enumerate(交并比列表.t()):
        无对象的掩码列表[图片索引列表[索引], 交并比 > 忽略用阈值, 目标盒子x取整列表[索引], 目标盒子y取整列表[索引]] = 0

    # 获取网格中的位置
    预设目标中x的列表[
        图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = 目标盒子x列表 - 目标盒子x列表.floor()
    预设目标中y的列表[
        图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = 目标盒子y列表 - 目标盒子y列表.floor()
    预设目标中宽的列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = torch.log(
        目标盒子宽列表 / 锚定盒列表[最佳_交并比索引列表][:, 0] + 1e-16)
    预设目标中高的列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = torch.log(
        目标盒子高列表 / 锚定盒列表[最佳_交并比索引列表][:, 1] + 1e-16)
    预设目标分类的列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表, 目标标签列表] = 1

    分类的掩码列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = (
            预测的分类列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表].argmax(-1)
            == 目标标签列表).float()
    交并比分数列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表] = 盒子边界的交并比(
        预测的盒子列表[图片索引列表, 最佳_交并比索引列表, 目标盒子x取整列表, 目标盒子y取整列表], 目标盒子列表,
        不转换坐标=False)
    exit()
